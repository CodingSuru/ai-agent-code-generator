import os
from datetime import datetime

class BackendAgent:
    def __init__(self):
        self.agent_name = "BackendAgent"
        self.output_dir = "outputs/backend"
        
    def generate(self, task):
        """Generate backend files based on task specification"""
        print(f"{self.agent_name}: Starting backend generation...")
        
        project_name = task['project_name']
        entity = task['entity']
        features = task['features']
        
        files = {}
        
        # Generate server.js
        print(f"   Generating server.js...")
        files['server.js'] = self.generate_server(entity, features)
        
        # Generate package.json
        print(f"   Generating package.json...")
        files['package.json'] = self.generate_package_json(project_name)
        
        # Generate model
        print(f"   Generating models/{entity}.js...")
        files[f'models/{entity}.js'] = self.generate_model(entity, features)
        
        # Generate routes
        print(f"   Generating routes/{entity}.js...")
        files[f'routes/{entity}.js'] = self.generate_routes(entity, features)
        
        # Write files to disk
        self.write_files(files)
        
        return files
    
    def generate_server(self, entity, features):
        """Generate Express server file"""
        # Build endpoints list safely to avoid invalid JS
        endpoints_items = [
            f"GET /api/{entity}s",
            f"POST /api/{entity}s",
            f"GET /api/{entity}s/:id",
            f"PUT /api/{entity}s/:id",
            f"DELETE /api/{entity}s/:id"
        ]
        if 'search' in features:
            endpoints_items.append("GET /api/search?q=query")

        endpoints_js = ",\n            ".join([f"'{item}'" for item in endpoints_items])

        server_code = f"""// Generated by {self.agent_name} on {datetime.now().isoformat()}

const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({{ extended: true }}));

// Serve static frontend files
app.use(express.static(path.join(__dirname, '../frontend')));

// Request logging
app.use((req, res, next) => {{
    console.log(`${{new Date().toISOString()}} - ${{req.method}} ${{req.url}}`);
    next();
}});

// Import routes
const {entity}Routes = require('./routes/{entity}');
app.use('/api', {entity}Routes);

// Health check endpoint
app.get('/health', (req, res) => {{
    res.json({{ 
        status: 'healthy', 
        timestamp: new Date().toISOString(),
        agent: '{self.agent_name}'
    }});
}});

// Root endpoint
app.get('/', (req, res) => {{
    res.json({{
        message: 'AI Agent Generated API',
        version: '1.0.0',
        endpoints: [
            {endpoints_js}
        ]
    }});
}});

// Error handling middleware
app.use((err, req, res, next) => {{
    console.error('Error:', err);
    res.status(500).json({{ 
        error: 'Internal server error',
        message: err.message 
    }});
}});

// 404 handler
app.use((req, res) => {{
    res.status(404).json({{ error: 'Endpoint not found' }});
}});

// Start server
app.listen(PORT, () => {{
    console.log('================================');
    console.log(`ðŸš€ Server running on port ${{PORT}}`);
    console.log(`ðŸ“¡ API URL: http://localhost:${{PORT}}`);
    console.log(`ðŸ¤– Generated by: {self.agent_name}`);
    console.log('================================');
}});

module.exports = app;"""
        return server_code
    
    def generate_package_json(self, project_name):
        """Generate package.json"""
        package = f"""{{
  "name": "{project_name.lower()}-backend",
  "version": "1.0.0",
  "description": "Auto-generated backend by AI Agent System",
  "main": "server.js",
  "scripts": {{
    "start": "node server.js",
    "dev": "nodemon server.js"
  }},
  "keywords": ["ai-agent", "express", "api"],
  "author": "AI Agent System - {self.agent_name}",
  "license": "MIT",
  "dependencies": {{
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "body-parser": "^1.20.2",
    "uuid": "^9.0.0"
  }},
  "devDependencies": {{
    "nodemon": "^3.0.1"
  }},
  "generatedBy": "{self.agent_name}",
  "generatedAt": "{datetime.now().isoformat()}"
}}"""
        return package
    
    def generate_model(self, entity, features):
        """Generate data model"""
        has_categories = 'categories' in features
        
        model_code = f"""// Generated by {self.agent_name} on {datetime.now().isoformat()}

const {{ v4: uuidv4 }} = require('uuid');

class {entity.capitalize()} {{
    constructor(data) {{
        this.id = data.id || uuidv4();
        this.title = data.title;
        this.content = data.content || '';
        {f"this.category = data.category || 'Uncategorized';" if has_categories else ''}
        this.createdAt = data.createdAt || new Date().toISOString();
        this.updatedAt = data.updatedAt || new Date().toISOString();
    }}
    
    update(data) {{
        if (data.title !== undefined) this.title = data.title;
        if (data.content !== undefined) this.content = data.content;
        {f"if (data.category !== undefined) this.category = data.category;" if has_categories else ''}
        this.updatedAt = new Date().toISOString();
        return this;
    }}
    
    toJSON() {{
        return {{
            id: this.id,
            title: this.title,
            content: this.content,
            {f"category: this.category," if has_categories else ''}
            createdAt: this.createdAt,
            updatedAt: this.updatedAt
        }};
    }}
}}

// In-memory database (replace with MongoDB/PostgreSQL in production)
class {entity.capitalize()}Database {{
    constructor() {{
        this.{entity}s = [];
        console.log(`âœ… {entity.capitalize()}Database initialized by {self.agent_name}`);
    }}
    
    create({entity}Data) {{
        const {entity} = new {entity.capitalize()}({entity}Data);
        this.{entity}s.push({entity});
        return {entity};
    }}
    
    findAll() {{
        return this.{entity}s;
    }}
    
    findById(id) {{
        return this.{entity}s.find({entity} => {entity}.id === id);
    }}
    
    update(id, data) {{
        const {entity} = this.findById(id);
        if (!{entity}) return null;
        return {entity}.update(data);
    }}
    
    delete(id) {{
        const index = this.{entity}s.findIndex({entity} => {entity}.id === id);
        if (index === -1) return false;
        this.{entity}s.splice(index, 1);
        return true;
    }}
    
    search(query) {{
        const lowerQuery = query.toLowerCase();
        return this.{entity}s.filter({entity} => 
            {entity}.title.toLowerCase().includes(lowerQuery) ||
            {entity}.content.toLowerCase().includes(lowerQuery)
            {f"|| {entity}.category.toLowerCase().includes(lowerQuery)" if has_categories else ''}
        );
    }}
}}

// Export singleton instance
const db = new {entity.capitalize()}Database();

module.exports = {{
    {entity.capitalize()},
    db
}};"""
        return model_code
    
    def generate_routes(self, entity, features):
        """Generate API routes"""
        has_search = 'search' in features
        has_edit = 'edit' in features
        has_delete = 'delete' in features
        
        routes_code = f"""// Generated by {self.agent_name} on {datetime.now().isoformat()}

const express = require('express');
const router = express.Router();
const {{ {entity.capitalize()}, db }} = require('../models/{entity}');

// ============================================
// GET ALL {entity.upper()}S
// ============================================
router.get('/{entity}s', (req, res) => {{
    try {{
        const {entity}s = db.findAll();
        res.json({entity}s);
    }} catch (error) {{
        console.error('Error fetching {entity}s:', error);
        res.status(500).json({{ error: 'Failed to fetch {entity}s' }});
    }}
}});

// ============================================
// GET SINGLE {entity.upper()} BY ID
// ============================================
router.get('/{entity}s/:id', (req, res) => {{
    try {{
        const {entity} = db.findById(req.params.id);
        if (!{entity}) {{
            return res.status(404).json({{ error: '{entity.capitalize()} not found' }});
        }}
        res.json({entity});
    }} catch (error) {{
        console.error('Error fetching {entity}:', error);
        res.status(500).json({{ error: 'Failed to fetch {entity}' }});
    }}
}});

// ============================================
// CREATE NEW {entity.upper()}
// ============================================
router.post('/{entity}s', (req, res) => {{
    try {{
        const {{ title, content{', category' if 'categories' in features else ''} }} = req.body;
        
        // Validation
        if (!title || title.trim() === '') {{
            return res.status(400).json({{ error: 'Title is required' }});
        }}
        
        const new{entity.capitalize()} = db.create({{
            title: title.trim(),
            content: content ? content.trim() : '',
            {f"category: category ? category.trim() : 'Uncategorized'" if 'categories' in features else ''}
        }});
        
        console.log(`âœ“ Created {entity}: ${{new{entity.capitalize()}.id}}`);
        res.status(201).json(new{entity.capitalize()});
    }} catch (error) {{
        console.error('Error creating {entity}:', error);
        res.status(500).json({{ error: 'Failed to create {entity}' }});
    }}
}});

{f'''// ============================================
// UPDATE {entity.upper()}
// ============================================
router.put('/{entity}s/:id', (req, res) => {{
    try {{
        const {{ title, content{', category' if 'categories' in features else ''} }} = req.body;
        
        const updated{entity.capitalize()} = db.update(req.params.id, {{
            title,
            content,
            {f"category" if 'categories' in features else ''}
        }});
        
        if (!updated{entity.capitalize()}) {{
            return res.status(404).json({{ error: '{entity.capitalize()} not found' }});
        }}
        
        console.log(`âœ“ Updated {entity}: ${{req.params.id}}`);
        res.json(updated{entity.capitalize()});
    }} catch (error) {{
        console.error('Error updating {entity}:', error);
        res.status(500).json({{ error: 'Failed to update {entity}' }});
    }}
}});''' if has_edit else ''}

{f'''// ============================================
// DELETE {entity.upper()}
// ============================================
router.delete('/{entity}s/:id', (req, res) => {{
    try {{
        const success = db.delete(req.params.id);
        
        if (!success) {{
            return res.status(404).json({{ error: '{entity.capitalize()} not found' }});
        }}
        
        console.log(`âœ“ Deleted {entity}: ${{req.params.id}}`);
        res.json({{ message: '{entity.capitalize()} deleted successfully' }});
    }} catch (error) {{
        console.error('Error deleting {entity}:', error);
        res.status(500).json({{ error: 'Failed to delete {entity}' }});
    }}
}});''' if has_delete else ''}

{f'''// ============================================
// SEARCH {entity.upper()}S
// ============================================
router.get('/search', (req, res) => {{
    try {{
        const query = req.query.q || '';
        if (query.trim() === '') {{
            return res.json(db.findAll());
        }}
        
        const results = db.search(query);
        console.log(`âœ“ Search for "${{query}}" returned ${{results.length}} results`);
        res.json(results);
    }} catch (error) {{
        console.error('Error searching {entity}s:', error);
        res.status(500).json({{ error: 'Failed to search {entity}s' }});
    }}
}});''' if has_search else ''}

module.exports = router;"""
        return routes_code
    
    def write_files(self, files):
        """Write generated files to disk"""
        # Create subdirectories if needed
        os.makedirs(os.path.join(self.output_dir, 'models'), exist_ok=True)
        os.makedirs(os.path.join(self.output_dir, 'routes'), exist_ok=True)
        
        for filename, content in files.items():
            filepath = os.path.join(self.output_dir, filename)
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"   Wrote {filepath}")